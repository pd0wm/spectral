%!TEX program = xelatex

\documentclass[a4paper, openany, oneside]{memoir}
\input{../../../includes/preamble.tex}
\addbibresource{../../../includes/bibliography.bib}

\title{Compressive Sensing - An Overview}

\author{W.P. Bruinsma \and R.P. Hes \and H.J.C. Kroep \and T.C. Leliveld \and W.M. Melching \and T.A. aan de Wiel}

\raggedbottom

\begin{document}
\chapter{Presenter - The Supervisor}
\label{cha:presenter}
In the model-view-presenter architectural pattern, the presenter forms the glue between the model and the view. In is packaged in the \lib{spectral\_supervisor} module. The model notifies the presenter whenever its state changes, which will then trigger the presenter to update the view using the new data. At the same time, the view notifies the presenter whenever a user interacts with it, upon which the presenter will take the necessary actions to reflect this user-event in the model.

In our implementation, the presenter is concerned with the following tasks:
\begin{itemize}
	\item Coordinate model and view actions.
	\item Manage system-wide settings during runtime.
	\item Update the view using current model data.
\end{itemize}

Control of model and view will be described in \cref{sec:control}. After this, the subject of system-wide execution parameters will be dealt with in \cref{sec:settings_server}. Finally, we will get into the matter of model-view interaction regarding settings and data in \cref{sec:websockets}.

\section{Primary control}
\label{sec:control}
Coordinating both model and view is primarily handled by the Python script \file{run.py}. This script may be executed with a number of command-line arguments:

\begin{description}
	\item[f\_samp] Specifies the sampling frequency the USRPs should operate at.
	\item[L] Specifies the L-parameter throughout the system, which determines the dimensions of various vectors and matrices.
	\item[source] Specifies what module should be used as a data source for the system, choices are the USRP, various theoretical sources such as a sinusoidal and a locally saved dump that was previously recorded.
	\item[snr] When a theoretical source is selected, this specifies the amount of Gaussian noise that should be added to the signal. Used to test the system's performance.
	\item[dump] When a local data dump is selected as source, this specifies where the dump file is located.
	\item[ip] When a USRP is selected as source, this specifies the IP-address of the USRP that should be used for data-acquisition.
	\item[controlport] Specifies the port at which the WebSocket (see \cref{sec:websockets}) that handles control of the system should connect.
	\item[dataport] Specifies the port at which the WebSocket that handles the data streams for external access should connect.
\end{description}

Using the parameters set by the user or a set of predefined defaults, The presenter will initialise each subcomponent in a separate process (using Python's \class{Process}, from the \lib{multiprocessing} library in \cite{pythonref}), allowing tasks to be handled concurrently. The current implementation runs six processes alongside each other, whose behaviour is defined in \file{processes.py} Python script. We defined the following sic processes:

\begin{enumerate}
	\item The generator and sampler, this can be any combination of one of the sources in \cref{sec:source} and one of the samplers in \cref{sec:sampling}.
	\item The reconstructor, from \cref{sec:reconstruction}.
	\item The detector, from \cref{sec:detection}.
	\item The web server, an important component of the view, as will be described in \cref{ch:view}.
	\item The control WebSocket server, which exposes the model's settings so that they can be modified from external applications (like the view).
	\item The data WebSocket server, which exposes the model's currently processed data for external applications.
\end{enumerate}

These processes need to be able to exchange data. This process is called inter-process communication (IPC). For example, the reconstructor process needs data generated by the generation process to perform its reconstruction. This is implemented using a number of Python \class{Queue}s (from Python's \lib{multiprocessing} library in \cite{pythonref}), wrapped in a class that implements safe queueing and de-queueing by means of locks.

\section{Settings server}
\label{sec:settings_server}
Managing system-wide settings and allowing the user to modify them at runtime are also tasks of the presenter. System settings are made available between different Python processes using the Python package \lib{Pyro4}. This package enables us to use Remote Procedure Calls, which means we can use external objects over sockets as if they were local. In our system it functions mainly as a means of IPC on localhost, but in theory it could be used as a central settings server from which a distributed network of computational machines get their settings and a number of views can push their settings to. This way of having system settings managed by a single object more or less maps to the Observer programming pattern \cite{msdn-observer}.

\section{WebSockets}
\label{sec:websockets}
To expose model settings and result data to external applications the system makes use of the WebSocket-protocol. The WebSocket protocol defines a full-duplex single socket connection that can be used to send messages between a client and server. The WebSocket specification was initially implemented in JavaScript, but nowadays interfaces are available in many other programming languages as well, including Python. Multiple packages even exist, of which \lib{Autobahn} was chosen, because of its ease of use and clear examples.

\subsection{Factories and Protocols}
\label{sub:autobahn}
\lib{Autobahn} implements the WebSocket specification using another widely used Python package called \lib{Twisted}, which is an event-driven network engine. When using \lib{Autobahn}, a WebSocket server is defined by a factory object and a protocol object. A factory is, simply put, an object that can create other objects, which is a basic object-oriented programming (OOP) pattern \cite{msdn-observer}. A factory is created for both the WebSocket servers once, at runtime, when their respective processes start. From that point, either factory will create a protocol object for every client that connects to the server. The factory will perform some initialisation on the protocol and pass a reference of itself along with it, so every protocol instance shares the same factory object, more or less like a parent.

The protocols themselves define the behaviour of the WebSocket server upon various events. Both protocols handle the same events, which are relatively straight-forward:
\begin{description}
	\item[\func{onConnect}] Triggered when a client tries to connect to the server.
	\item[\func{onOpen}] Triggered after a connection has been successfully established.
	\item[\func{onMessage}] Triggered when the server receives a message from the client.
	\item[\func{onClose}] Triggered when a connection with a client is closed.
\end{description}

\subsection{Settings}
\label{sub:websocket_settings}
The settings WebSocket server uses \lib{Pyro4} to access the model's settings and makes them available to any client that connects at request. The settings WebSocket server is defined by the \class{ServerProtocolControl} protocol class and the \class{ServerProtocolControlFactory} factory class.
Whenever a client connects (consecutively triggering \func{onConnect} and \func{onOpen}), the protocol will register itself with the parent factory. It will also send the connected client a message containing every current setting, so that the client may initialise itself correctly. Whenever a client sends an updated setting over the WebSocket connection (triggering \func{onMessage}), the protocol forwards the update via the \lib{Pyro4} settings object and makes sure any other client is notified of the changed setting via the parent factory, which relays the message to all clients that are currently registered by the factory. Finally, when a client disconnects, its associated protocol will unregister itself with the factory before going out of scope.

\subsection{Data}
\label{sub:websocket_data}
The data WebSocket server publishes model data to any client that connects to it . The data WebSocket server is defined by the \class{ServerProtocolData} protocol class and the \class{ServerProtocolDataFactory} factory class. It functions in a similar manner as the settings WebSocket server, but maintains a direct data connection with the model using queues as described in \cref{sec:control}, in stead of using \lib{Pyro4}. The generator, reconstructor and detector processes each have their own queue to which they push the currently processed data, so that it can be made available on the WebSocket. The queues and buffers are both held by the parent factory, so every protocol will read the same data.
The data WebSocket server does take any action when a client connects. Registering itself with the parent factory is not needed because connected clients do not interact with each other.
Any connected client may send the server a request for a certain data stream, coming from the generator, reconstructor or detector process.
When this happens, the associated protocol will ask the parent factory to update its data buffer for the correct process. Finally, the container will be encoded into a string using JSON\footnote{JavaScript Object Notation, a standardised way to express objects using a string} and send to the client.

\end{document}
