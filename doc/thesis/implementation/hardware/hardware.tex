%!TEX program = xelatex

\documentclass[a4paper, openany, oneside]{memoir}
\input{../../../includes/preamble.tex}
\addbibresource{../../../includes/bibliography.bib}

\title{Compressive Sensing - An Overview}

\author{W.P. Bruinsma \and R.P. Hes \and H.J.C. Kroep \and T.C. Leliveld \and W.M. Melching \and T.A. aan de Wiel}

\raggedbottom

\begin{document}
\chapter{Hardware}

\section{USRP N210}
\label{sec:usrp-n210}

\subsection{Introduction}
The hardware samplers used in our system was a USRP N210, a software defined radio (SDR) produced by \textit{Ettus Research}. This radio is equipped with the SBX front-end, which has frequency range of \SIrange{400}{4400}{\mega\hertz} that can both transmit and receive. This signal that enters the radio is first amplified and then mixed down by a two local oscillators with a \SI{90}{\degree} phase shift. Then the resulting two signals are sampled by two \SI{100}{\mega\sample\per\second} ADCs resulting in an I and a Q signal. Because the local oscillators have a \SI{90}{\degree} phase shift the resulting signal is quadrature/IQ sampled. With the information from both signals we measure the complex envelope of the signal.

The USRPs can also be used as a transmitter using the DAC and the same local oscillators. We used this during the testing of our design to generate test signals. However this is not used in our final design.

These radios are connected to a PC by using gigabit Ethernet, thus limiting the effective sample rate to \SI{25}{\mega\sample\per\second} with a 16 bit resolution or \SI{50}{\mega\sample\per\second} with an 8 bit resolution. If you want to use the full potential of the internal ADC (2x \SI{100}{\mega\sample\per\second}) and DAC (2x \SI{400}{\mega\sample\per\second}) you have to write your own firmware for the internal FPGA.

\subsection{Drivers}
\label{sec:drivers}
The communication between the USRPs and our software is handled by the UHD driver\footnote{The code for this driver can be found online at: \url{https://github.com/EttusResearch/uhd}} written by \textit{Ettus Research}.

In the first version of our software we built everything using \lib{GNU Radio}. We used the \lib{gnuradio-uhd} blocks to get samples from our USRPs. Soon we switched to a pure Python version, we still used the \lib{gnuradio-uhd} library to retrieve our samples. We used a specific helper function \func{gnuradio.uhd.finite\_acquisition(n)} from the GNU Radio libraries. This helper function started a low level stream, waits for n samples, closes the stream and returns the samples to the caller.

The USRPs have an automatic calibration for the DC offset introduced by the local oscillator after the mixer. However due to a bug in the USRPs, every time a stream is started this DC calibration is reset. This makes the \func{finite\_acquisition} unusable for our purposes.

To solve this we had to write our own low level code to stream samples from the device. We wrote \CC~code to connect to the USRPs, synchronise them and start a stream. The received samples are then send through a socket to the rest of the system for further processing. This was not an easy task, but has the added benefit that our system no longer depends on \lib{GNU Radio} and we have very low level control over the precise operation of the USRPs.


\subsection{Synchronisation}
For our implementation of co-prime sampling we needed to synchronise the sampling of two USRPs. This can be accomplished by connection them with a special MIMO cable. This allows them to internally synchronise their sampling clock. It even allows them to schedule commands at exactly the same time, so they can start sampling at exactly the same moment.

To verify that our synchronisation is correct, we dumped two frames from the same moment in time to a file. If we plot them on the same time scale, as in \cref{fig:plot_samplers}, we can see that they align almost perfectly. If we zoom in on the second burst in the signal, see \cref{fig:plot_samplers_zoom}, we can see the offset due to the local oscillator offset.

The only offset we have is from the phase offset between the two local oscillators of the USRPs. After each tune command the two USRPs have a random phase offset of \SIrange[retain-explicit-plus]{-180}{+180}{\degree}.  We don't know yet if that influences our results. If that is the case we can calculate this lag by looking at the cross-correlation between the two USRPs or by transmitting a reference pulse after each tune command and calculating the delay.



\begin{figure}[H]
\centering
\begin{tikzpicture}
\begin{axis}[
	xlabel={Samples},
	ylabel={Amplitude},
  ymin=-1e-2,
  ymax=1e-2,
  xmin=0,
  xmax=1e5,
	width=\textwidth, height=0.8\textwidth,
	xmajorgrids, xminorgrids, ymajorgrids,
  name=sampler_a
	]

%% Set the plot options, and load a csv formatted file %%
\addplot [
	color=black,
	solid,
	mark=.,
	]
	table [col sep=comma]{plots/coprime_orig_a.csv};
\end{axis}

\begin{axis}[
	xlabel={Samples},
	ylabel={Amplitude},
  ymin=-1e-2,
  ymax=1e-2,
  xmin=0,
  xmax=4e4,
	width=\textwidth, height=0.8\textwidth,
	xmajorgrids, xminorgrids, ymajorgrids,
  at=(sampler_a.below south), anchor=above north
	]

%% Set the plot options, and load a csv formatted file %%
\addplot [
	color=black,
	solid,
	mark=.,
	]
	table [col sep=comma]{plots/coprime_orig_b.csv};
\end{axis}
\end{tikzpicture}
\caption{Output of the two samplers}
\label{fig:plot_samplers}
\end{figure}

\begin{figure}[H]
\centering
\begin{tikzpicture}
\begin{axis}[
	xlabel={Samples},
	ylabel={Amplitude},
  ymin=-1e-2,
  ymax=1e-2,
  xmin=0,
  xmax=100,
	width=\textwidth, height=0.8\textwidth,
	xmajorgrids, xminorgrids, ymajorgrids,
	]

%% Set the plot options, and load a csv formatted file %%
\addplot [
	color=blue,
	solid,
	mark=.,
	]
	table [col sep=comma]{plots/coprime_resamp_a.csv};

%% Set the plot options, and load a csv formatted file %%
\addplot [
	color=green,
	solid,
	mark=.,
	]
	table [col sep=comma]{plots/coprime_resamp_b.csv};
\end{axis}
\end{tikzpicture}
\caption{Zoomed in version of the samples}
\label{fig:plot_samplers_zoom}
\end{figure}

\end{document}
